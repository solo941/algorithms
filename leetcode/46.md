# 739
题目描述：一组不重复的整数，返回它们所有的组合。

```
Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

解题思路：不重复给的提示是哈希表，组合问题是典型的回溯问题。回溯解决问题的固定套路是

添加 -> 递归深度 -> 回溯删除

```java
public List<List<Integer>> permute(int[] nums) {
      List<Integer> list = new ArrayList<>();
      List<List<Integer>> allLists = new ArrayList<>();
      boolean[] visited = new boolean[nums.length];
      search(0, visited, list, allLists, nums);
      return allLists;
    }
    public void search(int length, boolean[]visited, List<Integer> list, 
                       List<List<Integer>> allLists,int[] nums){
        if(length == nums.length){
            allLists.add(list);
            return;
        }
        for(int i = 0; i < nums.length; i++){
            if(visited[i]) continue;
            visited[i] = true;
            list.add(nums[i]);
            search(length+1, visited, list, allLists, nums);
            list.remove(list.size() - 1);
            visited[i] = false;
        }
    }
```

可是提交后，列表里只有空列表，仔细分析，错误发生在添加列表时，传的是对象的地址，而这个list是会在回溯时删掉的。这里涉及到了java基本类型传值，引用类型传地址的值的知识点。

```java
public List<List<Integer>> permute(int[] nums) {
      List<Integer> list = new ArrayList<>();
      List<List<Integer>> allLists = new ArrayList<>();
      boolean[] visited = new boolean[nums.length];
      search(0, visited, list, allLists, nums);
      return allLists;
    }
    public void search(int length, boolean[]visited, List<Integer> list, 
                       List<List<Integer>> allLists,int[] nums){
        if(length == nums.length){
             //这个地方传的是对象的地址，list后面都会变成空，所以new对象
            allLists.add(new ArrayList<>(list));
            return;
        }
        for(int i = 0; i < nums.length; i++){
            if(visited[i]) continue;
            visited[i] = true;
            list.add(nums[i]);
            search(length+1, visited, list, allLists, nums);
            list.remove(list.size() - 1);
            visited[i] = false;
        }
    }
```
