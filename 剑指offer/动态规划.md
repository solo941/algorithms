# 动态规划

## 正则匹配

题目描述：请实现一个函数用来匹配包括'.'和'\*'的正则表达式。模式中的字符'.'表示任意一个字符，而'\*'表示它前面的字符可以出现任意次（包含0次）。      在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab\*ac\*a"匹配，但是与"aa.a"和"ab*a"均不匹配。

解题思路：需要将字符串和模式逐位匹配，因为存在字符'\*'，需要考虑前一位的字符，前后存在状态转移关系，状态是能否匹配，因此使用二维动态规划求解。初始状态,null与null匹配，且任意字符后跟'\*'可以与null匹配，如'n*'可表示0个n。

```java
boolean[][] dp = new boolean[m + 1][n + 1];
int m = str.length, n = pattern.length;
dp[0][0] = true;
    for (int i = 1; i <= n; i++)
        if (pattern[i - 1] == '*')
            dp[0][i] = dp[0][i - 2];

```

从字符串第一位开始，要与模式对应位置比较，这里要特别考虑字符'\*'，此时要与模式的前一位比较(a与a*)。如果相等，分三种情况讨论:

- a出现0次：dp\[i][j] |= dp\[i][j - 2];
- a出现1次：dp\[i][j] |= dp\[i][j - 1];
- a出现多次，如baa和ba*:dp\[i][j] |= dp\[i-1][j];

如果不相等，如a与b*，只能当作b出现0次，不然一定不匹配。

```java
public boolean match(char[] str, char[] pattern)
    {
        int m = str.length;
        int n = pattern.length;
        boolean[][] dp = new boolean[m+1][n+1];
        dp[0][0] = true;
        for(int i = 1; i <= n; i++){
            if(pattern[i-1] == '*') dp[0][i] = dp[0][i-2]; //null, a*
        }
        for(int i = 1; i <= m; i++)
            for(int j = 1; j <= n; j++){
                if(str[i-1] == pattern[j-1] || pattern[j-1] == '.') dp[i][j] = dp [i-1][j-1];
                else if(pattern[j-1] == '*'){
                    if(str[i-1] == pattern[j-2] || pattern[j-2] == '.'){
                        dp[i][j] = dp[i-1][j-1]| dp[i][j-1] | dp[i-1][j] | dp[i][j-2];
                    }
                    else dp[i][j] = dp[i][j-2];
                }
            }
        return dp[m][n];
    }
```

