# 面试题11:旋转数组的最小数字

## 题目描述

 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。  输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。  NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

解题思路：典型的二分查找时间复杂度`O(logn)`。但应该注意元素相等的情况，[1,0,1,1,1]和[1,1,1,0,1]两种情况，此时无法确定最小元素在mid的左还是右，因此只能将首部或者尾部元素移动一位。代码如下：

```java
public class Solution {
    public int minNumberInRotateArray(int[] nums) {
    if (nums.length == 0)
        return 0;
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] < nums[h])
            h = m;
        else if(nums[m] == nums[h]) h--;
        else
            l = m + 1;
    }
    return nums[l];
	}
}
```

上面的可以通过，但下面与首位比较只能过40。

```java
public int minNumberInRotateArray(int [] array) {
        if(array.length == 0) return 0;
        int n = array.length;
        int l =0, h = n -1;
        while(l < h){
            int mid = l + (h - l) / 2;
            if(array[mid] > array[l]) l = mid + 1;
            else if(array[mid] == array[l]) l++;
            else h = mid;
        }
        return array[l];
    }
```

出现这种错误的原因，只有两个元素是，如[0,1]，mid =0, 此时arr[mid]与arr[l]比较，都是0相等，会返回1.因此只能与末尾去比较，才能保证mid与比较位之间数字的单调性。