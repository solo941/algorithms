## 面试题11:旋转数组的最小数字

 题目描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。  输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。  NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

解题思路：典型的二分查找时间复杂度`O(logn)`。但应该注意元素相等的情况，[1,0,1,1,1]和[1,1,1,0,1]两种情况，此时无法确定最小元素在mid的左还是右，因此只能将首部或者尾部元素移动一位。代码如下：

```java
public class Solution {
    public int minNumberInRotateArray(int[] nums) {
    if (nums.length == 0)
        return 0;
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] < nums[h])
            h = m;
        else if(nums[m] == nums[h]) h--;
        else
            l = m + 1;
    }
    return nums[l];
	}
}
```

上面的可以通过，但下面与首位比较只能过40。

```java
public int minNumberInRotateArray(int [] array) {
        if(array.length == 0) return 0;
        int n = array.length;
        int l =0, h = n -1;
        while(l < h){
            int mid = l + (h - l) / 2;
            if(array[mid] > array[l]) l = mid + 1;
            else if(array[mid] == array[l]) l++;
            else h = mid;
        }
        return array[l];
    }
```

出现这种错误的原因，只有两个元素是，如[0,1]，mid =0, 此时arr[mid]与arr[l]比较，都是0相等，会返回1.因此只能与末尾去比较，才能保证mid与比较位之间数字的单调性。

## 面试题50：第一个只出现一次的字符

在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）

解题思路：第一个方法最简单，hashmap存字符和出现次数，第二次遍历找出现次数为1的即可。

```java
public class Solution {
    Map<Character,Integer> map = new HashMap();
    public int FirstNotRepeatingChar(String str) {
        int n = str.length();
        if(str == null || n == 0) return -1;
        for(int i = 0; i < n; i++){
            if(!map.containsKey(str.charAt(i))) 
                map.put(str.charAt(i), 1);
            else map.put(str.charAt(i), map.get(str.charAt(i)) + 1);
        }
        for(int i = 0; i < n; i++){
            if(map.get(str.charAt(i)) == 1) return i;
        }
        return -1;
    }
}
```

但使用hashmap效率低，考虑到char是一个长度位8的数据类型，共有256种可能，使用数组存储提高效率。

```java
public int FirstNotRepeatingChar(String str) {
    int[] cnts = new int[256];
    for (int i = 0; i < str.length(); i++)
        cnts[str.charAt(i)]++;
    for (int i = 0; i < str.length(); i++)
        if (cnts[str.charAt(i)] == 1)
            return i;
    return -1;
}
```

以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。

```java
public int FirstNotRepeatingChar2(String str) {
    BitSet bs1 = new BitSet(256);
    BitSet bs2 = new BitSet(256);
    for (char c : str.toCharArray()) {
        if (!bs1.get(c) && !bs2.get(c))
            bs1.set(c);     // 0 0 -> 0 1
        else if (bs1.get(c) && !bs2.get(c))
            bs2.set(c);     // 0 1 -> 1 1
    }
    for (int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        if (bs1.get(c) && !bs2.get(c))  // 0 1
            return i;
    }
    return -1;
}
```

bitset总结连接：