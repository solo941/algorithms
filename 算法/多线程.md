## 两个线程交替打印

题目描述：两个线程交替打印1-100.

解题思路：使用`volatile`和`bool`变量控制，可避免使用`synchronized`导致的上下文切换带来的损耗。

```java
public class TwoThread {
    private volatile int count = 1;
    private volatile boolean flag = false;
    private final static Lock LOCK = new ReentrantLock();

    public static void main(String[] args) {
        TwoThread twoThread = new TwoThread();
        Thread t1 = new Thread(new JiNum(twoThread));
        t1.setName("t1");
        Thread t2 = new Thread(new OuNum(twoThread));
        t2.setName("t2");
        t1.start();
        t2.start();
    }
    public static class OuNum implements Runnable{
        private  TwoThread thread;
        public OuNum(TwoThread thread){
            this.thread = thread;
        }
        @Override
        public void run() {
            while (thread.count <= 100){
                if (thread.flag){
                    try {
                        LOCK.lock();
                        System.out.println(Thread.currentThread().getName()+"..."+thread.count);
                        thread.count++;
                        thread.flag = false;
                    }finally {
                        LOCK.unlock();
                    }
                }
            }
        }
    }
    public static class JiNum implements Runnable{
        private  TwoThread thread;
        public JiNum(TwoThread thread){
            this.thread = thread;
        }
        @Override
        public void run() {
            while (thread.count <= 100){
                if (!thread.flag){
                    try {
                        LOCK.lock();
                        System.out.println(Thread.currentThread().getName()+"..."+thread.count);
                        thread.count++;
                        thread.flag = true;
                    }finally {
                        LOCK.unlock();
                    }
                }
            }
        }
    }
}
```

上面的代码`count`没有使用`volatile`修饰，可能会读取旧值，因为并非原子的，如下图所示，奇数线程读取`count`值并非偶数线程修改后的值101，而是100，导致多输出一次：

