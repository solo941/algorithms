# 多线程通信

题目描述：两个线程交替打印1-100.针对这个问题，我们从以下几种方法入手：

## 等待通知机制

两个线程通过对同一对象调用等待 wait() 和通知 notify() 方法来进行通讯。

```java
public class TwoThreadWaitNotify {

    private int start = 1;

    private boolean flag = false;

    public static void main(String[] args) {
        TwoThreadWaitNotify twoThread = new TwoThreadWaitNotify();

        Thread t1 = new Thread(new OuNum(twoThread));
        t1.setName("A");


        Thread t2 = new Thread(new JiNum(twoThread));
        t2.setName("B");

        t1.start();
        t2.start();
    }

    /**
     * 偶数线程
     */
    public static class OuNum implements Runnable {
        private TwoThreadWaitNotify number;

        public OuNum(TwoThreadWaitNotify number) {
            this.number = number;
        }

        @Override
        public void run() {

            while (number.start <= 100) {
                synchronized (TwoThreadWaitNotify.class) {
                    System.out.println("偶数线程抢到锁了");
                    if (number.flag) {
                        System.out.println(Thread.currentThread().getName() + "+-+偶数" + number.start);
                        number.start++;
                        number.flag = false;
                        TwoThreadWaitNotify.class.notify();

                    }else {
                        try {
                            TwoThreadWaitNotify.class.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }

            }
        }
    }


    /**
     * 奇数线程
     */
    public static class JiNum implements Runnable {
        private TwoThreadWaitNotify number;

        public JiNum(TwoThreadWaitNotify number) {
            this.number = number;
        }

        @Override
        public void run() {
            while (number.start <= 100) {
                synchronized (TwoThreadWaitNotify.class) {
                    System.out.println("奇数线程抢到锁了");
                    if (!number.flag) {
                        System.out.println(Thread.currentThread().getName() + "+-+奇数" + number.start);
                        number.start++;

                        number.flag = true;

                        TwoThreadWaitNotify.class.notify();
                    }else {
                        try {
                            TwoThreadWaitNotify.class.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
    }
}
```

有一些需要注意:

- wait() 、notify()、notifyAll() 调用的前提都是获得了对象的锁(也可称为对象监视器)。
- 调用 wait() 方法后线程会释放锁，进入 `WAITING` 状态，该线程也会被移动到**等待队列**中。
- 调用 notify() 方法会将**等待队列**中的线程移动到**同步队列**中，线程状态也会更新为 `BLOCKED`
- 从 wait() 方法返回的前提是调用 notify() 方法的线程释放锁，wait() 方法的线程获得锁。

## volatile共享内存

使用`volatile`和`bool`变量控制，可避免使用`synchronized`导致的上下文切换带来的损耗。

```java
public class TwoThread {
    private volatile int count = 1;
    private volatile boolean flag = false;
    private final static Lock LOCK = new ReentrantLock();

    public static void main(String[] args) {
        TwoThread twoThread = new TwoThread();
        Thread t1 = new Thread(new JiNum(twoThread));
        t1.setName("t1");
        Thread t2 = new Thread(new OuNum(twoThread));
        t2.setName("t2");
        t1.start();
        t2.start();
    }
    public static class OuNum implements Runnable{
        private  TwoThread thread;
        public OuNum(TwoThread thread){
            this.thread = thread;
        }
        @Override
        public void run() {
            while (thread.count <= 100){
                if (thread.flag){
                    try {
                        LOCK.lock();
                        System.out.println(Thread.currentThread().getName()+"..."+thread.count);
                        thread.count++;
                        thread.flag = false;
                    }finally {
                        LOCK.unlock();
                    }
                }
            }
        }
    }
    public static class JiNum implements Runnable{
        private  TwoThread thread;
        public JiNum(TwoThread thread){
            this.thread = thread;
        }
        @Override
        public void run() {
            while (thread.count <= 100){
                if (!thread.flag){
                    try {
                        LOCK.lock();
                        System.out.println(Thread.currentThread().getName()+"..."+thread.count);
                        thread.count++;
                        thread.flag = true;
                    }finally {
                        LOCK.unlock();
                    }
                }
            }
        }
    }
}
```

上面的代码`count`没有使用`volatile`修饰，可能会读取旧值，因为并非原子的，如下图所示，奇数线程读取`count`值并非偶数线程修改后的值101，而是100，导致多输出一次：

![pic](https://github.com/solo941/algorithms/blob/master/算法/pics/TwoThread.png)

## join()

线程中调用另一个线程的join()方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。

```java
private static void join() throws InterruptedException {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                LOGGER.info("running");
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }) ;
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                LOGGER.info("running2");
                try {
                    Thread.sleep(4000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }) ;

        t1.start();
        t2.start();

        //等待线程1终止
        t1.join();

        //等待线程2终止
        t2.join();

        LOGGER.info("main over");
    }
```

`t1`和`t2`线程都结束后，主线程退出。

# J.U.C - AQS

## CountDownLatch

`CountDownLatch` 可以实现 join 相同的功能，但是更加的灵活。维护了一个计数器 cnt，每次调用 `countDown()` 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。

```java
 private static void countDownLatch() throws Exception{
        int thread = 3 ;
        long start = System.currentTimeMillis();
        final CountDownLatch countDown = new CountDownLatch(thread);
        for (int i= 0 ;i<thread ; i++){
            new Thread(new Runnable() {
                @Override
                public void run() {
                    LOGGER.info("thread run");
                    try {
                        Thread.sleep(2000);
                        countDown.countDown();

                        LOGGER.info("thread end");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }

        countDown.await();
        long stop = System.currentTimeMillis();
        LOGGER.info("main over total time={}",stop-start);
    }
```

适用于主线程等待多个线程。

## **CyclicBarrier**

用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。`CyclicBarrier` 和 `CountdownLatch` 的一个区别是，`CyclicBarrier` 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。

```java
private static void cyclicBarrier() throws Exception {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(3) ;

        new Thread(new Runnable() {
            @Override
            public void run() {
                LOGGER.info("thread run");
                try {
                    cyclicBarrier.await() ;
                } catch (Exception e) {
                    e.printStackTrace();
                }

                LOGGER.info("thread end do something");
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                LOGGER.info("thread run");
                try {
                    cyclicBarrier.await() ;
                } catch (Exception e) {
                    e.printStackTrace();
                }

                LOGGER.info("thread end do something");
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                LOGGER.info("thread run");
                try {
                    Thread.sleep(5000);
                    cyclicBarrier.await() ;
                } catch (Exception e) {
                    e.printStackTrace();
                }

                LOGGER.info("thread end do something");
            }
        }).start();

        LOGGER.info("main thread");
    }
```

调用 `await()` 将会在所有参与者线程都调用之前等待。直到所有参与者都调用了 `await()` 后，所有线程从 `await()` 返回继续后续逻辑。这里主线程不会等待，只有调用 `await()` 的线程会等待。

```
六月 15, 2019 12:50:13 上午 com.leetcode.CyclicBarrierDemo cyclic
信息: main thread
六月 15, 2019 12:50:13 上午 com.leetcode.CyclicBarrierDemo$3 run
信息: thread run
六月 15, 2019 12:50:13 上午 com.leetcode.CyclicBarrierDemo$2 run
信息: thread run
六月 15, 2019 12:50:13 上午 com.leetcode.CyclicBarrierDemo$1 run
信息: thread run
六月 15, 2019 12:50:18 上午 com.leetcode.CyclicBarrierDemo$3 run
信息: thread end do something
六月 15, 2019 12:50:18 上午 com.leetcode.CyclicBarrierDemo$1 run
信息: thread end do something
六月 15, 2019 12:50:18 上午 com.leetcode.CyclicBarrierDemo$2 run
信息: thread end do something
```

## Semaphore

Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数,作用就是有限资源，线程限流。

```java
public class SemaphoreExample {

    public static void main(String[] args) {
        final int clientCount = 3;
        final int totalRequestCount = 10;
        Semaphore semaphore = new Semaphore(clientCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalRequestCount; i++) {
            executorService.execute(()->{
                try {
                    semaphore.acquire();
                    System.out.print(semaphore.availablePermits() + " ");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                }
            });
        }
        executorService.shutdown();
    }
}
```

